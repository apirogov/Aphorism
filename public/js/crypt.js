/* Wrapper for the RSA library and custom functions
 * Copyright (C) 2010 Anton Pirogov
 * Licensed under the GPLv3 or later
 */

/*****************  RSA Wrapper functions ***********************/
if (RSA == null || typeof(RSA) != "object") { var RSA = new Object();} /* create namespace if does not exist */

RSA = {
	/* input: plaintext, public key
	 * output: cipher (crypted text as hex) */
	encrypt: function(text, key) {
		var rsa = new RSAKey();
  		rsa.setPublic(key.n, key.e);
  		var res = rsa.encrypt(text);
  		return res;
	},

	/* input: cipher (crypted text as hex), private key (as generated by genRSAKeys)
 	* output: plaintext */
	decrypt: function(cipher, key) {
	 	/* create key object as required by rsa algorithm and set the numbers from hex */
 	 	var rsa = new RSAKey();
 		rsa.setPrivateEx(key.n, key.e, key.d, key.p, key.q, key.dmp1, key.dmq1, key.coeff);

  		/* decrypt and return string */
  		var res = rsa.decrypt(cipher);
  		return res;
	},

			 // TODO: MAKE VERIFY AND SIGN WORK
	/* encrypting with private key */
//	sign: function(text,key) {
//		var rsa = new RSAKey();
//		rsa.setPublic(key.n, key.d); // use d instead of e -> signing
//		
//		var res = rsa.encrypt(text);
//		return res;
//	},

	/* decrypting with public key */
//	verify: function(cipher, key) {
//		var rsa = new RSAKey();
//
		/* recalculate the stuff, with e and d swapped.. */
//		var e = new BigInteger(key.e, 16);
//		var p = new BigInteger(key.p, 16);
//		var q = new BigInteger(key.q, 16);
//		var dmp1 = e.mod(p.subtract(new BigInteger("1",10)));
//		var dmq1 = e.mod(q.subtract(new BigInteger("1",10)));
//		var coeff = new BigInteger("1",10);
//		coeff = coeff.divide(q).mod(p);

// 		rsa.setPrivateEx(key.n, key.d, e.toString(16), p.toString(16), q.toString(16),
//				dmp1.toString(16), dmq1.toString(16), coeff.toString(16));

//		var res = rsa.decrypt(cipher);
//		return res;
//	},
	
	/* return key data (all numbers as hex) (with private) */
	gen_keys: function(bits) {
	  	/* default key size */
  		if(typeof bits == "undefined")
	  	bits = 1024;

  		var rsa = new RSAKey();
		rsa.generate(parseInt(bits),"10001"); /* take 10001 (hex) as e */
		return {
	  		"e": rsa.e.toString(16),
	  		"n": rsa.n.toString(16),
	  		"d": rsa.d.toString(16),
	  		"p": rsa.p.toString(16),
	  		"q": rsa.q.toString(16),
	  		"dmp1": rsa.dmp1.toString(16),
	 		"dmq1": rsa.dmq1.toString(16),
	  		"coeff": rsa.coeff.toString(16)
  		};
	},

	/* just exponent and modulus - public key */
	get_public_key: function(privkey) {
		return {"e": privkey.e, "n": privkey.n };
	}
}

